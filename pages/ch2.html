
<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
    <head>
        <title>SystemVerilog Training </title>
        <link href="../imgs/icon.svg" rel="icon">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700%7CRoboto+Slab:700%7CRoboto:400,400i,700" rel="stylesheet"><link href="../dltorch.css" rel="stylesheet" type="text/css">
        <meta charset="UTF-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <meta content="./" property="og:url">
        <meta content="../imgs/icon.png" property="og:image">
        <meta content="SystemVerilog Training" property="og:title">
        <meta content="SystemVerilog Training" property="og:description">
        <meta content="article" property="og:type">
        <meta content="summary" name="twitter:card">
        
<!-- 
#===============================================================#
#                    Make a slideshow                           #
#===============================================================#
-->    
<style>
* {box-sizing: border-box}
.mySlides {display: none}
img {vertical-align: middle;}

/* Slideshow container */
.slideshow-container {
  max-width: 1000px;
  position: relative;
  margin: auto;
}

/* Next & previous buttons */
.prev, .next {
  cursor: pointer;
  position: absolute;
  top: 50%;
  width: auto;
  padding: 16px;
  margin-top: -22px;
  color: #005AFF;
  font-weight: bold;
  font-size: 18px;
  transition: 0.6s ease;
  border-radius: 0 3px 3px 0;
  user-select: none;
}

/* Position the "next button" to the right */
.next {
  right: 0;
  border-radius: 3px 0 0 3px;
}

/* On hover, add a black background color with a little bit see-through */
.prev:hover, .next:hover {
  background-color: rgba(0,0,0,0.8);
}

/* Caption text */
.text {
  color: #f2f2f2;
  font-size: 15px;
  padding: 8px 12px;
  position: absolute;
  bottom: 8px;
  width: 100%;
  text-align: center;
}

/* Number text (1/3 etc) */
.numbertext {
  color: #f2f2f2;
  font-size: 12px;
  padding: 8px 12px;
  position: absolute;
  top: 0;
}

/* The dots/bullets/indicators */
.dot {
  cursor: pointer;
  height: 10px;
  width: 10px;
  margin: 0 2px;
  background-color: #bbb;
  border-radius: 50%;
  display: inline-block;
  transition: background-color 0.6s ease;
}

.active, .dot:hover {
  background-color: #717171;
}

/* Fading animation */
.fade {
  animation-name: fade;
  animation-duration: 1.5s;
}

@keyframes fade {
  from {opacity: .5} 
  to {opacity: 1}
}

/* On smaller screens, decrease text size */
@media only screen and (max-width: 300px) {
  .prev, .next,.text {font-size: 11px}
}
</style>
        
    </head>
    
    <body>
<!-- 
#===============================================================#
#                    Make a Tabs                                #
#===============================================================#
--> 
        <div id="wrap">
            <div id="heading">
                
                <div class="menubar menufirst">
                    <span class="menugroup"><a href="../index.html" class="menubutton selected" title=" ">Materials</a></span>
                </div>
                
                <div id="titleblock">
                    <h1>SystemVerilog Training </br> <p style="font-size: 16px">Jaywant Kulkarni, Taha Heidari</p></h1>
                </div>


                
                <div class="menubar menusecond">
                    <span class="menugroup">
                        <a href="../index.html" class="menubutton" title="Introduction">Intro</a>
                    </span>
                    

<span class="menugroup">
                        <a href="../pages/ch1.html" class="menubutton" title="Chapter 1: Simple Gates">1- AND, OR, XOR, NAND, NOR Gates</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch2.html" class="menubutton selected" title="Chapter 2">2- Multiplexer Blocks</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch3.html" class="menubutton" title="Chapter 3">3- Half/Full Adder Blocks</a>
		</span>
<span class="menugroup">
                        <a href="../pages/ch4.html" class="menubutton" title="Chapter 4">4- D Flip Flop</a>
		</span>
<span class="menugroup">
                        <a href="../pages/ch5.html" class="menubutton" title="Chapter 5">5- Register Blocks</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch6.html" class="menubutton" title="Chapter 6">6- Counters</a>
		</span>
<span class="menugroup">
                        <a href="../pages/ch7.html" class="menubutton" title="Chapter 7">7- Shift Registers</a>
		</span>
<span class="menugroup">
                        <a href="../pages/ch8.html" class="menubutton" title="Chapter 8">8- Serial Ports</a>
		</span>
<span class="menugroup">
                        <a href="../pages/ch9.html" class="menubutton" title="Chapter 9">9- 32×8 Register File</a>
		</span>
<span class="menugroup">
                        <a href="../pages/ch10.html" class="menubutton" title="Chapter 10">10- 1024×32 DPRAM</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch11.html" class="menubutton" title="Chapter 11">11- AXI LITE Slave BUS</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch12.html" class="menubutton" title="Chapter 12">12- AXI LITE Address Decoder</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch13.html" class="menubutton" title="Chapter 13">13- Simple DMA Engine</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch14.html" class="menubutton" title="Chapter 14">14- AXI LITE ARBITER</a>
		</span>

<span class="menugroup">
                        <a href="../pages/ch15.html" class="menubutton" title="Chapter 15">15- Simple FIR Filter (16-tap)</a>
		</span>



                </div>
            
<div id="maintitle"><h1> </h1></div>

<div class="menubar menuthird">

<span class="menugroup"><a href="../pages/ch2.html#t1" class="menubutton selected" title="">Task1: <br/>mux_2</a><a href="../pages/ch2.html#t2" class="menubutton" title=" ">Task2: <br/>mux_4</a><a href="../pages/ch2.html#t3" class="menubutton" title=" ">Task3: <br/>mux_8</a><a href="../pages/ch2.html#t4" class="menubutton" title=" ">Task4: <br/>mux_16</a></span>

</div>
<div class="example">                
<h3>Notes:</h3>
<ul><li><p align="justify"><b>Combinational logic</b> <br />Combinational logic is a type of digital logic where the output is solely determined by the current inputs, without any memory of past inputs. This contrasts with <b>sequential logic</b> , where outputs can be influenced by previous states and inputs, essentially having memory. Combinational logic circuits perform operations based on Boolean algebra and are fundamental in creating circuits like adders, multiplexers, and arithmetic logic units (ALUs).</p>
    <p align="justify"> It refers to the type of logic circuits or expressions that result from continuous assignments or procedural blocks like always_comb. It represents a class of digital circuits built using basic logic gates (AND, OR, NOT, etc.) and does not involve any timing elements like flip-flops or latches</p></li></ul>
<div class="example">
<p align="justify"><strong>always_comb</strong><br /><span style="background-color: #dcdcdc">always_comb</span> is a procedural block that is intended for combinational logic. It allows for more complex expressions and multiple assignments within the same block. It’s sensitive to all changes in the variables used within the block, ensuring that the logic is always up-to-date with the current inputs. It also infers a complete sensitivity list automatically, which means you don’t need to specify which signals it should react to.</p>
<p align="justify"><strong>Continuous assignment</strong><br />Continuous assignment with <span style="background-color: #dcdcdc">assign</span> is used for simpler, direct assignments. It’s a declarative statement that continuously assigns a value to a wire based on an expression. It’s typically used for straightforward expressions and can only define one signal with one equation at a time.</p>  
    <p align="justify">It’s used to model combinational logic, which is logic that computes outputs solely based on the current inputs without any memory or storage elements. Continuous assignment statements are always active and reflect changes in the inputs immediately.</p>
    <center>
<figure><img src="../imgs/ch2_0_1.png" style="width:100%">
    <figcaption><p align="justify">Fig.0 - always_comb VS continues assignment: <b>combinational logic</b> is generally used for more complex combinational logic where multiple assignments or more expressive logic is needed, while <b>assign</b> is used for simpler, direct wire assignments. Both result in combinational logic without storage elements, but always_comb can offer more expressiveness and is more explicit in its intent to represent combinational logic.</p><p align="justify">The first module uses a procedural block (always_comb), which is triggered whenever any of the inputs change. It uses an if statement to explicitly check the value of sel and assign y to either a or b accordingly. This is a more traditional style of writing hardware logic in Verilog, similar to writing software.</p><p align="justify">The second module uses a continuous assignment (assign) statement, which is a declarative way of defining the relationship between inputs and outputs. It uses bitwise operations to determine the value of y based on sel, a, and b. This style is more concise and often preferred for simple combinational logic as it can be easier to read and understand.</p>
        <p align="justify"><strong>Bitwise VS Logical operators</strong><br />
        The difference between assign y = (sel & a) | (~sel & b); and assign y = (sel && a) | (~sel && b); in Verilog lies in the use of bitwise operators (&, |) versus logical operators (&&, ||).
<br /><b>The bitwise operators (&, |)</b> operate on each bit of the operands. In the expression assign y = (sel & a) | (~sel & b);, sel & a and ~sel & b perform bit-wise AND operations, and the results are combined using a bit-wise OR operation. This is the correct way to implement multiplexer logic in hardware description languages like Verilog1.
<br /><b>The logical operators (&&, ||)</b> are used for logical comparisons and return a single bit result, which is either 1'b1 (true) or 1'b0 (false). In the expression assign y = (sel && a) | (~sel && b);, sel && a and ~sel && b perform logical AND operations, which are not suitable for bit-level hardware descriptions because they treat the entire operand as a single boolean entity. <b>Logical operators are typically used for control flow decisions and single-bit comparisons.</b></p></figcaption>
</figure>
</center>
</div>
</div>
            
<div id="maintitle"><h1 id="t1">Task 1: <a href="">mux_2</a></h1></div>
</div>
            
            <div id="body">
    
<p align="justify">In this exercise, you are required to implement a 2-input multiplexer (MUX) with the following input, output, and functionalities.</p>
<center>
<figure><img src="../imgs/ch2_1_1.png" style="width:30%">
<figcaption>Fig.1 - 2-input Multiplexer (MUX).</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_1_2.png" style="width:30%">
<figcaption>Fig.2 - Truth Table of 2-input MUX.</figcaption>
</figure>
</center>

<strong>Inputs:</strong> 
<p align="justify">The inputs to the MUX are 1 bit wide and are named "a", "b", and "sel" where "a" and "b" are data inputs and "sel" is the selection input.</p>
<strong>Output:</strong> 
<p align="justify">The output of the MUX is a single bit and is named "y", assigning y = (sel & a) | (~sel & b).</p>
<strong>Functionality: </strong>
<p align="justify">A multiplexer outputs the value of either "a" or "b" based on the value of the selection input "sel". If "sel" is 0, the output is equal to "b"; if "sel" is 1, the output is equal to "a".</p>
<strong>Testbench:</strong>
<p align="justify">You need to create a module and define its name, outputs, and inputs. The module name can be mux_2 with "a", "b", and "sel" variables as its inputs and "y" as its output. Then you should also define the equation between output and input using the assign command. After creating a MUX, to test your module, you need to create a testbench module which instantiates the MUX inside it with a certain name. There you need to specify the input and output types (logic) and attach (wire) them to the instantiated MUX. After this, you need to give different values to input variables as well as some delay time (using #100 ns) to see the output changes over time within the input changes.</p>
<center>
<figure><img src="../imgs/ch2_1_3.png" style="width:60%">
<figcaption>Fig.3 - Testbench structure.</figcaption>
</figure>
</center>
 <center>
<figure><img src="../imgs/ch2_1_4.png" style="width:60%">
<figcaption>Fig.4 - Module code.</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_1_5.png" style="width:60%">
<figcaption>Fig.4 - Testbench code.</figcaption>
</figure>
</center>                      

</div>                

                
<div id="maintitle"><h1 id="t2">Task 2: <a href="">mux_4</a></h1></div>

<div id="body">
    
<strong>Functionality: </strong>
<p align="justify">The multiplexer selects one of the 4 inputs based on the 2-bit selection signal sel and outputs it through y. The testbench applies different input combinations and observes the output y after a delay of 100 time units.</p>
    <p align="justify">4-input multiplexer can be also implemented using 3 2-input multiplexers as implemented above as shown in figure 2.2. Try to implement the mux_4 block in both ways.</p>

<center>
<figure><img src="../imgs/ch2_2_1.png" style="width:40%">
<figcaption>Fig.2.1 - 4-input Mux gate.</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_2_2.png" style="width:70%">
<figcaption>Fig.2.2 - 4-input Mux gate using a combination of 2-input muxes .</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_2_3.png" style="width:45%">
<figcaption>Fig.2.3 - Truth Table of 4-input Mux gate.</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_2_4.png" style="width:100%">
<figcaption>Fig.2.4 - Testbench structure (right: combination of mux_2s, left: single mux_4).</figcaption>
</figure>
</center>
    
                
                
                <div id="maintitle"><h1 id="t3">Task 3: <a href="">mux_8</a></h1></div>
            </div>
            
            <div id="body">
    
<strong>Functionality: </strong>
<p align="justify">The multiplexer selects one of the 8 inputs based on the 3-bit selection signal sel and outputs it through y. The testbench applies different input combinations and observes the output y after a delay of 100 time units.</p>
    <p align="justify">8-input multiplexer can be also implemented using 5 2-input multiplexers as shown in figure 3.2 or a combination of 2 4-input muxes together with a single 2-input mux as shown in figure 3.3. Try to implement the mux_4 block in both ways.</p>
<center>
<figure><img src="../imgs/ch2_3_1.png" style="width:40%">
<figcaption>Fig.3.1 - 8-input Mux gate.</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_3_2.png" style="width:80%">
<figcaption>Fig.3.2 - 8-input Mux gate using a combination of 2-input muxes .</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_3_3.png" style="width:70%">
<figcaption>Fig.3.2 - 8-input Mux gate using a combination of 4-input muxes and a single 2-input mux.</figcaption>
</figure>
</center>                
<center>
<figure><img src="../imgs/ch2_3_4.png" style="width:30%">
<figcaption>Fig.3.3 - Truth Table of 2-input AND gate.</figcaption>
</figure>
</center>


<center>
<figure><img src="../imgs/ch2_3_3.png" style="width:60%">
<figcaption>Fig.3 - Testbench structure.</figcaption>
</figure>
</center>
                
                                <div id="maintitle"><h1 id="t4">Task 4: <a href="">mux_16</a></h1></div>
            </div>
            
            <div id="body">
    
<p align="justify">In this exercise you are required to implement an 2-input AND gate with the following input, output and functionalities.</p>
<center>
<figure><img src="../imgs/ch2_4_1.png" style="width:30%">
<figcaption>Fig.1 - 2-input AND gate.</figcaption>
</figure>
</center>
<center>
<figure><img src="../imgs/ch2_4_2.png" style="width:30%">
<figcaption>Fig.2 - Truth Table of 2-input AND gate.</figcaption>
</figure>
</center>

<center>
<figure><img src="../imgs/ch2_4_3.png" style="width:60%">
<figcaption>Fig.3 - Testbench structure.</figcaption>
</figure>
</center>

<br>


                

                
            </div>
    <div id="footer"></div>
            
            
    </div>
        

        
        
        
<!-- 
#===============➫=➫=======⤳=====================➥===============#
#                    Make a slideshow with JS 
#https://www.rapidtables.com/web/html/link/html-anchor-link.html#example
https://css-tricks.com/on-adding-ids-to-headers/
#===============================================================#
-->    

<script>
let slideIndex = 1;
showSlides(slideIndex);

function plusSlides(n) {
  showSlides(slideIndex += n);
}

function currentSlide(n) {
  showSlides(slideIndex = n);
}

function showSlides(n) {
  let i;
  let slides = document.getElementsByClassName("mySlides");
  let dots = document.getElementsByClassName("dot");
  if (n > slides.length) {slideIndex = 1}    
  if (n < 1) {slideIndex = slides.length}
  for (i = 0; i < slides.length; i++) {
    slides[i].style.display = "none";  
  }
  for (i = 0; i < dots.length; i++) {
    dots[i].className = dots[i].className.replace(" active", "");
  }
  slides[slideIndex-1].style.display = "block";  
  dots[slideIndex-1].className += " active";
}
</script>
        
        
    </body>
</html>
